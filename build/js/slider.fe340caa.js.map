{"version":3,"sources":["scripts/slider.js"],"names":["sliderCards","document","querySelectorAll","divSliderDots","querySelector","createSliderDots","i","length","insertAdjacentHTML","btnLeft","btnRight","sliderCardsCont","sliderWrapper","sliderDots","classList","add","style","transition","slideWidth","xStart","xEnd","xCurr","distanceX","xDrag","outBounds","touchStartX","touchStartY","touchEndX","touchCurrX","touchCurrY","touchDistanceX","touchDragX","touchDragY","noScroll","shownImage","setSlideWidth","window","innerWidth","slideToImage","manualSlideDist","arguments","undefined","transform","removeSliderDotActive","_step","_iterator","_createForOfIteratorHelper","s","n","done","value","remove","err","e","f","slideToLeft","Math","floor","round","slideToRight","turnOnSliderDots","forEach","sliderDot","onclick","slideByDrag","onmouseenter","ontouchstart","onmousedown","clientX","onmousemove","onmouseup","onmouseleave","slider","slideWithButtons","key","slowerSlideWithButtons","setTimeout","addEventListener","once","event","changedTouches","screenX","screenY","_step2","_iterator2","body","ontouchmove","abs","overflow","onscroll","_step3","_iterator3","screen","orientation","console","log"],"mappings":"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","file":"slider.fe340caa.js","sourceRoot":"../../assets/src","sourcesContent":["// создаём точки слайдера\nconst sliderCards = document.querySelectorAll('.slider__card');\nconst divSliderDots = document.querySelector('.slider__dots');\n\nfunction createSliderDots() {\n    let i = 0;\n    while (i < (sliderCards.length / 3)) {\n        // divSliderDots.appendChild(sliderDot); - не добавляет один и тот же элемент больше одного раза\n        divSliderDots.insertAdjacentHTML(\"beforeend\", '<div class=\"slider__dot\"></div>');\n        i++;\n        // console.log(i);\n    }\n\n    // добавляем точки для версий сладера с двумя карточками на экране - в дополнение к уже созданным точкам. \n    // продолжаем счётчик i, отредактировав условие while - указав сколько точек должно быть в итоге \n    while (i < (sliderCards.length / 2)) {\n        divSliderDots.insertAdjacentHTML(\"beforeend\", '<div class=\"slider__dot slider__dot_2card\"></div>');\n        i++;\n        // console.log(i);\n    }\n\n    // добавляем точки для версий сладера с одной карточкой на экране\n    while (i < sliderCards.length) {\n        divSliderDots.insertAdjacentHTML(\"beforeend\", '<div class=\"slider__dot slider__dot_1card\"></div>');\n        i++;\n        // console.log(i);\n    }\n\n}\ncreateSliderDots();\n\n// функционал слайдера\nconst btnLeft = document.querySelector('.btn_arrow_l');\nconst btnRight = document.querySelector('.btn_arrow_r');\nconst sliderCardsCont = document.querySelector('.slider__cards-cont');\nconst sliderWrapper = document.querySelector('.slider__wrapper');\nlet sliderDots = document.querySelectorAll('.slider__dot');\n\n// делаем активной первую точку слайдера\nsliderDots[0].classList.add('slider__dot_active');\n\nsliderCardsCont.style.transition = '0.3s';\nsliderWrapper.style.transition = '0.3s';\n\nlet shownImage = 0; // задаём индекс отображаемой картинки (карточки) - (при загрузке страницы отображается первая карточка, её индекс 0 )\nlet slideWidth; // расстояние сдвига карточек при листании (ширина карточки + расстояние между карточками)\n\nfunction setSlideWidth() {\n    if (window.innerWidth < 375) {\n        slideWidth = 30 + 2.4; //ширина карточки + расстояние между карточками\n    } else if (window.innerWidth < 425) {\n        slideWidth = 35.4 + 2.4; //ширина карточки + расстояние между карточками\n    } else {\n        slideWidth = 38.4 + 2.4; //ширина карточки + расстояние между карточками\n    }\n}\nsetSlideWidth();\n\nfunction slideToImage(shownImage, manualSlideDist = 0) {\n    //смещаем внутреннюю обёртку карточек внутри внешней с overflow:hidden; (\"окошка\") \n    sliderWrapper.style.transform = 'translateX(' + ((-(shownImage * slideWidth)) + ((manualSlideDist) / 10)) + 'rem)';\n}\n\nfunction removeSliderDotActive() {\n    for (let sliderDot of sliderDots) {\n        sliderDot.classList.remove('slider__dot_active');\n    }\n}\n\nfunction slideToLeft() {\n    shownImage--; // уменьшаем индекс отображаемой картинки на 1 (т.к. мы листаем вправо)\n\n    // задаём на какую карточку при листании назад с первой краточки нужно будет переходить, в зависимости от ширины экрана (т.е. кол-ва отображаемых карточек в окне слайдера)\n    if (window.innerWidth < 825) {\n        if (shownImage < 0) {\n            shownImage = (sliderCards.length - 1);\n        };\n    } else if (window.innerWidth < 1250) {\n        if (shownImage < 0) {\n            shownImage = (sliderCards.length - 2);\n        };\n    } else if (shownImage < 0) {\n        shownImage = (sliderCards.length - 3);\n    };\n\n    // console.log(shownImage);\n\n    setSlideWidth();\n    slideToImage(shownImage);\n\n    removeSliderDotActive();\n\n    // в зависимости от ширины экрана (и кол-ва отображаемых точек) добавляем только отображаемые точки в массив (перезаписывая его)\n    // for 1-card slider (window.innerWidth < 825)\n    if (window.innerWidth < 825) {\n        sliderDots = divSliderDots.querySelectorAll('.slider__dot');\n        // console.log(sliderDots);\n        sliderDots[shownImage].classList.add('slider__dot_active');\n    }\n    else\n        // for 2-card slider (window.innerWidth < 1250)\n        if (window.innerWidth < 1250) {\n            sliderDots = divSliderDots.querySelectorAll('.slider__dot:not(.slider__dot_1card)');\n            // console.log(sliderDots);\n            sliderDots[Math.floor(shownImage / 2)].classList.add('slider__dot_active');\n        }\n        else {\n            // for 3-card slider (window.innerWidth > 1250)\n            sliderDots = divSliderDots.querySelectorAll(\".slider__dot:not(.slider__dot_2card):not(.slider__dot_1card)\");\n            // console.log(sliderDots);\n            sliderDots[Math.round(shownImage / 3)].classList.add('slider__dot_active');\n        }\n}\n\nfunction slideToRight() {\n    shownImage++; // увеличиваем индекс отображаемой картинки на 1 (т.к. мы листаем вправо)\n    // задаём на какой карточке при листании вперёд нужно будет переходить к первой карточке, в зависимости от ширины экрана (т.е. кол-ва отображаемых карточек в окне слайдера)\n    if (window.innerWidth < 825) {\n        if (shownImage >= (sliderCards.length)) {\n            shownImage = 0;\n        }\n    } else if (window.innerWidth < 1250) {\n        if (shownImage >= (sliderCards.length - 1)) {\n            shownImage = 0;\n        }\n    } else if (shownImage >= (sliderCards.length - 2)) {\n        shownImage = 0;\n    }\n\n    setSlideWidth();\n    slideToImage(shownImage);\n\n    removeSliderDotActive();\n\n    // в зависимости от ширины экрана (и кол-ва отображаемых точек) добавляем только отображаемые точки в массив (перезаписывая его)\n    // for 1-card slider (window.innerWidth < 825)\n    if (window.innerWidth < 825) {\n        sliderDots = divSliderDots.querySelectorAll('.slider__dot');\n        // console.log(sliderDots);\n        sliderDots[shownImage].classList.add('slider__dot_active');\n    }\n    else\n        // for 2-card slider (window.innerWidth < 1250)\n        if (window.innerWidth < 1250) {\n            sliderDots = divSliderDots.querySelectorAll('.slider__dot:not(.slider__dot_1card)');\n            // console.log(sliderDots);\n            sliderDots[Math.floor(shownImage / 2)].classList.add('slider__dot_active');\n\n        } else {\n            // for 3-card slider (window.innerWidth > 1250)\n            sliderDots = divSliderDots.querySelectorAll(\".slider__dot:not(.slider__dot_2card):not(.slider__dot_1card)\");\n            // console.log(sliderDots);\n            sliderDots[Math.round(shownImage / 3)].classList.add('slider__dot_active');\n        }\n}\n\nbtnRight.onclick = slideToRight;\nbtnLeft.onclick = slideToLeft;\n\n\n\n\n// при наведении (вхождении курсора мыши - т.е. однократно) на контейнер с точками (divSliderDots - .slider__dots) в зависимости от window.innerWidth создаем массив только из отображаемых точек и присваиваем точкам (из вновь созданного массива sliderDots) действие перелистывания слайдера по клику:\nfunction turnOnSliderDots() {\n\n    removeSliderDotActive();\n    // в зависимости от ширины экрана (и кол-ва отображаемых точек) добавляем только отображаемые точки в массив (перезаписывая его):\n    // for 1-card slider (window.innerWidth < 825)\n    if (window.innerWidth < 825) {\n        sliderDots = divSliderDots.querySelectorAll('.slider__dot');\n        // console.log(sliderDots);\n        sliderDots[shownImage].classList.add('slider__dot_active');\n    }\n    else\n        // for 2-card slider (window.innerWidth < 1250)\n        if (window.innerWidth < 1250) {\n            sliderDots = divSliderDots.querySelectorAll('.slider__dot:not(.slider__dot_1card)');\n            // console.log(sliderDots);\n            sliderDots[Math.floor(shownImage / 2)].classList.add('slider__dot_active');\n        }\n        else {\n            // for 3-card slider (window.innerWidth > 1250)\n            sliderDots = divSliderDots.querySelectorAll(\".slider__dot:not(.slider__dot_2card):not(.slider__dot_1card)\");\n            // console.log(sliderDots);\n            sliderDots[Math.round(shownImage / 3)].classList.add('slider__dot_active');\n        }\n\n    // присваиваем точкам (из вновь созданного массива sliderDots) действие перелистывания слайдера по клику\n    sliderDots.forEach((sliderDot, i) => {\n        sliderDot.onclick = () => {\n            if (window.innerWidth < 825) {\n                shownImage = i;\n            } else if (window.innerWidth < 1250) {\n                shownImage = i * 2;\n            } else {\n                shownImage = i * 3;\n            }\n            setSlideWidth();\n            slideToImage(shownImage);\n\n            // убираем со всех точек класс slider__dot_active и вешаем его на ту точку, по которой кликнули\n            removeSliderDotActive();\n            sliderDots[i].classList.add('slider__dot_active');\n        }\n    });\n}\n\nturnOnSliderDots();\n\ndivSliderDots.onmouseenter = turnOnSliderDots;\ndivSliderDots.ontouchstart = turnOnSliderDots;\n\n\n\n// MOUSE DRAG touch slider\n\nlet xStart;\nlet xEnd;\nlet xCurr;\nlet distanceX; // расстояние между нажатием и отжатием мышки\nlet xDrag; //  расстояние между нажатием и убиранием указателя мыши за пределы sliderWrapper\n\nlet outBounds; // маркер что мы не отжали мышку над sliderWrapper а убрали указатель за его пределы\n\nsliderWrapper.onmousedown = (e) => {\n    // e.preventDefault(); // чтоб не перетягивалась картинка -  от этого \"зависал\" на ПК. :hover на карточке - переделал через CSS: .card__img {pointer-events: none;}\n    // e.stopPropagation();\n    // console.log(e);\n    // console.log(e.clientX);\n    // console.log(e.clientY);\n    xStart = e.clientX;\n    // console.log(xStart);\n    outBounds = true;\n\n    sliderWrapper.style.transition = '0.016s';\n\n    setSlideWidth();\n    sliderWrapper.onmousemove = (e) => {\n        xCurr = e.clientX;\n        xDrag = (xCurr - xStart) * 1.5; // 1.5 - коэфф. увеличения \"движения мыши\"\n        // console.log(xDrag);\n        // console.log(((shownImage * slideWidth) - (xDrag / 10)));\n        sliderWrapper.style.transform = 'translateX(' + ((-(shownImage * slideWidth)) + (xDrag / 10)) + 'rem)';\n        // slideToImage(manualSlideDist = xDrag);\n    }\n}\n\nfunction slideByDrag(distanceX) {\n    if (distanceX < ((-slideWidth / 2) * 10) * 0.4) {\n        slideToRight();\n        if (distanceX < ((-3 * slideWidth / 2) * 10) * 0.9) {\n            slideToRight();\n        }\n    } else {\n        if (distanceX > ((slideWidth / 2) * 10) * 0.4) {\n            slideToLeft();\n            if (distanceX > ((3 * slideWidth / 2) * 10) * 0.9) {\n                slideToLeft();\n            }\n        } else {\n            sliderWrapper.style.transform = 'translateX(' + (-(shownImage * slideWidth)) + 'rem)';\n        }\n    }\n}\n\nsliderWrapper.onmouseup = (e) => {\n    outBounds = false;  // сбрасываем маркер что мышь не отжали над sliderWrapper\n    sliderWrapper.style.transition = '0.3s';\n    //e.preventDefault(); // чтоб не перетягивалась картинка\n    xEnd = e.clientX;\n    // console.log(xEnd);\n    distanceX = (xEnd - xStart) * 1.5; // 1.5 - коэфф. увеличения \"движения мыши\"\n    // console.log(distanceX);\n    slideByDrag(distanceX);\n    // убираем следование карточек за указателем мыши\n    sliderWrapper.onmousemove = undefined;\n\n}\n\nsliderWrapper.onmouseleave = () => {\n    if (outBounds === true) {\n\n        slideByDrag(xDrag);\n\n        outBounds = false;  // т.к. мы уже выполнили необходимое действие, поэтому сбрасываем маркер что мышь не отчали над sliderWrapper\n        sliderWrapper.style.transition = '0.3s';\n\n        sliderWrapper.onmousemove = undefined;\n    }\n}\n\n//\n//  TOUCH SCREENS touch slider\n\n//https://css-tricks.com/simple-swipe-with-vanilla-javascript/\n// https://codepen.io/thebabydino/pen/QQRwRy/\n\n//https://stackoverflow.com/questions/62823062/adding-a-simple-left-right-swipe-gesture\n\nlet touchStartX;\nlet touchStartY;\nlet touchEndX;\nlet touchCurrX;\nlet touchCurrY;\nlet touchDistanceX; // расстояние между началом и окончанием касания\nlet touchDragX; //  расстояние между  началом касания и текущим касанием или из-за выхода за пределы sliderWrapper\nlet touchDragY;\n\nlet noScroll;\n\nconst slider = document.querySelector('.slider');\n\n// let currWindowScrollY;\n\nslider.addEventListener('touchstart', function (event) {\n    touchStartX = event.changedTouches[0].screenX;\n    touchStartY = event.changedTouches[0].screenY;\n    //event.preventDefault();// блокирует скроол страницы на айфоне при касании слайдера - не очень удобно\n\n    // currWindowScrollY = window.scrollY;\n\n    // to remove stucked hover on iphone\n    for (let sliderCard of sliderCards) {\n        sliderCard.classList.remove('card_no-hover');\n    }\n    sliderWrapper.style.transition = '0.016s';\n    setSlideWidth();\n\n    // console.log(window.scrollY);\n    document.body.ontouchmove = (event) => {\n        touchCurrX = event.changedTouches[0].screenX;\n        touchCurrY = event.changedTouches[0].screenY;\n        touchDragX = (touchCurrX - touchStartX) * 1.5; // 1.5 - коэфф. увеличения \"движения касания\"\n        // slideToImage(manualSlideDist = xDrag);\n\n        touchDragY = touchCurrY - touchStartY;\n\n        // if (Math.abs(touchDragX) > 10) {\n        if (Math.abs(touchDragX) > (0.75 * Math.abs(touchDragY))) {\n            document.body.style.overflow = 'hidden';\n            sliderWrapper.style.transform = 'translateX(' + ((-(shownImage * slideWidth)) + (touchDragX / 10)) + 'rem)';\n\n        } else {\n\n            document.body.style.overflow = 'visible';\n            // document.body.style.position = 'relative';\n\n            sliderWrapper.style.transform = 'translateX(' + (-(shownImage * slideWidth)) + 'rem)';\n\n        }\n    }\n\n    // Чтобы при скролле страницы не листался слайдер (выглядит странно) - при событии скролла снимаем слушатель touchmove.\n    document.body.onscroll = () => {\n        // console.log('document.body.onscroll fires')\n        document.body.ontouchmove = undefined;\n    }\n\n    // }\n    // noScroll = setTimeout(() => {\n    //     document.body.style.overflow = 'hidden'\n    // }, 135);\n}, false);\n\nslider.addEventListener('touchend', function (event) {\n    sliderWrapper.style.transition = '0.3s';\n    touchEndX = event.changedTouches[0].screenX;\n    touchDistanceX = (touchEndX - touchStartX) * 1.5; // 1.5 - коэфф. увеличения \"движения касания\"\n    slideByDrag(touchDistanceX);\n    // убираем следование карточек за касанием\n    document.body.ontouchmove = undefined\n\n    // to remove stucked hover on iphone\n    for (let sliderCard of sliderCards) {\n        sliderCard.classList.add('card_no-hover');\n    }\n\n    // clearTimeout(noScroll);\n    document.body.style.overflow = 'visible';\n\n\n}, false);\n\nslider.addEventListener('touchcancel', function (event) {\n\n    // clearTimeout(noScroll);\n    document.body.style.overflow = 'visible';\n}, false);\n\n// \n// Выравниваем слайды после изменения ориентации (поворота) экрана (без этого слайды становятся криво, пока не пролистаешь вручную)\n// if (screen.orientation === true) {\nif (screen.orientation) {\n    // Не работает на iOS ((\n    screen.orientation.addEventListener(\"change\", () => {\n        // ставим задержку -  без задержки слайды не выравниваются\n        setTimeout(() => {\n            // (заново) рассчитываем ширину сдвига (с отсрочкой после поворота экрана)\n            setSlideWidth();\n            // сдвигаем на текущий слайд\n            sliderWrapper.style.transform = 'translateX(' + (-(shownImage * slideWidth)) + 'rem)';\n            console.log('screen orient change');\n        }, 133);\n    });\n} else {\n    console.log(\"device doesn't support screen.orientation\")\n}\n\n// работает на iOS )\nwindow.addEventListener(\"orientationchange\", function () {\n    // ставим задержку -  без задержки слайды не выравниваются\n    setTimeout(() => {\n        // (заново) рассчитываем ширину сдвига (с отсрочкой после поворота экрана)\n        setSlideWidth();\n        // сдвигаем на текущий слайд\n        sliderWrapper.style.transform = 'translateX(' + (-(shownImage * slideWidth)) + 'rem)';\n    }, 133);\n    //  // выводим тех. информацию\n    // console.log('aligned slider');\n    // if (window.orientation == 0 || window.orientation == 180) {\n    //     console.log('screen orient change - IN PORTRAIT MODE');\n    // } else {\n    //     console.log('screen orient change - IN LANDSCAPE MODE');\n    // }\n}, false);\n//\n\n// Убрать БАГ с зависающим ховером на iPhone при перелистывании - сделано через ('card_no-hover');\n\n//\n// Slide with Buttons\nfunction slideWithButtons(e) {\n    // console.log(e);\n    if (e.key === 'ArrowRight') {\n        slideToRight();\n    } else if (e.key === 'ArrowLeft') {\n        slideToLeft();\n    }\n}\n\nfunction slowerSlideWithButtons(e) {\n    slideWithButtons(e);\n    setTimeout(() => {\n        document.addEventListener('keydown', slowerSlideWithButtons, { once: true });\n    }, 300);\n}\n\ndocument.addEventListener('keydown', slowerSlideWithButtons, { once: true });"]}