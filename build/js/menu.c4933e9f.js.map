{"version":3,"sources":["scripts/menu.js"],"names":["btnMenuToggle","document","querySelector","menu","header","main","nav","catalog","btnMobSubMenu","btnCatDesktOpener","mainLogoMixblend","openMenu","window","innerWidth","style","zIndex","classList","add","scrollTo","top","left","behavior","body","overflow","height","setTimeout","addEventListener","closeMenu","event","removeProperty","target","remove","removeEventListener","once","onclick","toggle","menuItems","querySelectorAll","forEach","menuItem","i","animationDelay","catMenuItems","catMenuItem"],"mappings":";AAAA,IAAMA,EAAgBC,SAASC,cAAc,sBACvCC,EAAOF,SAASC,cAAc,iBAC9BE,EAASH,SAASC,cAAc,WAChCG,EAAOJ,SAASC,cAAc,SAC9BI,EAAML,SAASC,cAAc,gBAC7BK,EAAUN,SAASC,cAAc,yBACjCM,EAAgBP,SAASC,cAAc,2BACvCO,EAAoBR,SAASC,cAAc,oBAE3CQ,EAAmBT,SAASC,cAAc,wBAGhD,SAASS,IACDC,OAAOC,WAAa,KACpBH,EAAiBI,MAAMC,OAAS,KAGhCZ,EAAKa,UAAUC,IAAI,uBAMnBL,OAAOM,SAAS,CAAEC,IAAK,EAAGC,KAAM,EAAGC,SAAU,WAG7CpB,SAASqB,KAAKR,MAAMS,SAAW,SAC/BtB,SAASqB,KAAKR,MAAMU,OAAS,QAG7BlB,EAAIU,UAAUC,IAAI,0BAElBV,EAAQS,UAAUC,IAAI,wCACtBjB,EAAcgB,UAAUC,IAAI,4BAIhCQ,WAAW,WACPxB,SAASyB,iBAAiB,QAASC,IACpC,IAGP,SAASA,EAAUC,GACflB,EAAiBI,MAAMe,eAAe,WAIlCD,EAAME,SAAWtB,IAEjBL,EAAKa,UAAUe,OAAO,uBACtBxB,EAAQS,UAAUe,OAAO,gCACzBzB,EAAIU,UAAUe,OAAO,wBACrBxB,EAAQS,UAAUe,OAAO,wCACzB/B,EAAcgB,UAAUe,OAAO,2BAG/B9B,SAASqB,KAAKR,MAAMS,SAAW,UAI/BtB,SAAS+B,oBAAoB,QAASL,GACtClB,EAAkBiB,iBAAiB,QAASf,EAAU,CAAEsB,MAAM,KAOtEzB,EAAc0B,QAAU,WACpB3B,EAAQS,UAAUmB,OAAO,iCAG7B1B,EAAkBiB,iBAAiB,QAASf,EAAU,CAAEsB,MAAM,IAI9D,IAAMG,EAAYnC,SAASoC,iBAAiB,sBAC5CD,EAAUE,QAAQ,SAACC,EAAUC,GAIzBD,EAASzB,MAAM2B,eAAkB,EAAKD,EAAI,GAAO,MAGrD,IAAME,EAAezC,SAASoC,iBAAiB,8BAC/CK,EAAaJ,QAAQ,SAACK,EAAaH,GAE/BG,EAAY7B,MAAM2B,eAAkBD,EAAI,GAAM","file":"menu.c4933e9f.js","sourceRoot":"../../assets/src","sourcesContent":["const btnMenuToggle = document.querySelector('.header__icon-menu');\nconst menu = document.querySelector('.header__menu');\nconst header = document.querySelector('.header');\nconst main = document.querySelector('.main');\nconst nav = document.querySelector('.header__nav');\nconst catalog = document.querySelector('.header__catalog-menu');\nconst btnMobSubMenu = document.querySelector('.header__submenu-opener');\nconst btnCatDesktOpener = document.querySelector('.header__catalog');\n\nconst mainLogoMixblend = document.querySelector('.main__logo_mixblend');\n\n\nfunction openMenu() {\n    if (window.innerWidth < 768) {\n        mainLogoMixblend.style.zIndex = '-1';\n\n        // console.log('btnMenuToggle.onclick');\n        menu.classList.add('header__menu_mobile');\n\n        // btnMenuToggle.removeEventListener('click', openMenu); не надо убирать т.к листнер вешался с { once: true }\n\n        // перематывем страницу вверх (к меню) - на случай если меню откроют когда иконка меню уже  частично скрыта перемоткой\n        // window.scrollTo(0, 0);\n        window.scrollTo({ top: 0, left: 0, behavior: 'smooth' });\n        // запрещаем прокрутку страницы при открытии меню\n        // на iPhone всё равно можно прокрутить страницу - выглядит очень странно. - Делаем непрозрачный фиксированный фон в цвет и добавляем лого, дублируя HTML\n        document.body.style.overflow = 'hidden';\n        document.body.style.height = '100vh';\n        // main.style.filter = 'contrast(0.01)';\n\n        nav.classList.add('header__nav_mob-menu');\n    } else {\n        catalog.classList.add('header__catalog-menu_visible-desktop');\n        btnMenuToggle.classList.add('header__icon-menu_close');\n    }\n\n    // вешаем листнер закрытия с задержкой т.к. если не сделать задержку листнер закрытия мгновенно повесится на документ и обработается клик который его же и повесил - меню откроется и закроется мгновенно - т.е. не откроется вообще\n    setTimeout(() => {\n        document.addEventListener('click', closeMenu);\n    }, 16);\n}\n\nfunction closeMenu(event) {\n    mainLogoMixblend.style.removeProperty('z-index');\n    // mainLogoMixblend.style.zIndex = '';\n\n    //  объединил закрытие мобильного и десктоп меню в одну функцию без условий по ширине экрана - закрывает ВСË.\n    if (event.target !== btnMobSubMenu) {\n        // console.log('document.addEventListener click');\n        menu.classList.remove('header__menu_mobile');\n        catalog.classList.remove('header__catalog-menu_visible');\n        nav.classList.remove('header__nav_mob-menu');\n        catalog.classList.remove('header__catalog-menu_visible-desktop');\n        btnMenuToggle.classList.remove('header__icon-menu_close');\n\n        // возобновляем возможность прокрутки страницы при закрытии меню\n        document.body.style.overflow = 'visible';\n\n        // main.style.filter = 'none';\n\n        document.removeEventListener('click', closeMenu);\n        btnCatDesktOpener.addEventListener('click', openMenu, { once: true });\n    }\n}\n\n// повесили этот листнер на btnCatDesktOpener\n// btnMenuToggle.addEventListener('click', openMenu, { once: true });\n\nbtnMobSubMenu.onclick = () => {\n    catalog.classList.toggle('header__catalog-menu_visible');\n}\n\nbtnCatDesktOpener.addEventListener('click', openMenu, { once: true });\n\n\n// устанавливаем задерку анимации (чтобы не писать вручную через CSS)\nconst menuItems = document.querySelectorAll('.header__menu-item');\nmenuItems.forEach((menuItem, i) => {\n    // console.log(menuItem + ' - ' + i);\n    // console.log(menuItem);\n    // console.log((0 + (i / 15)) + 's');\n    menuItem.style.animationDelay = (0 + (i / 15)) + 's';\n});\n\nconst catMenuItems = document.querySelectorAll('.header__catalog-menu-item');\ncatMenuItems.forEach((catMenuItem, i) => {\n    // console.log(catMenuItem);\n    catMenuItem.style.animationDelay = (i / 15) + 's';\n})\n\n\n// повесить отдельный дублирующий листнер закрытия мобильного меню на кнопку закрытия моб.меню - на всякий случай  - не надо т.к. функция closeMenu закрывает ВСЕ меню - и мобильное и десктопное\n\n\n\n\n// Если зарегистрировано несколько одинаковых EventListener-ов на одном EventTarget с одинаковыми параметрами, дублирующиеся слушатели игнорируются. Они не позволяют EventListener-у быть вызванным дважды, и так как одинаковые слушатели игнорируются, не требуется удалять их вручную с помощью метода removeEventListener. \n// То есть список разрастается потихоньку, что, конечно, не очень то хорошо, но события повторно не вызываются.\n// https://developer.mozilla.org/ru/docs/Web/API/EventTarget/addEventListener"]}