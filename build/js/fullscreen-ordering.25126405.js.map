{"version":3,"sources":["scripts/fullscreen-ordering.js"],"names":["orderingInitHeight","orderingImgCont","document","querySelector","orderingImgContOuter","ordering","orderingOuter","footer","html","enterFullscreenSection","window","innerHeight","offsetHeight","style","scrollPaddingTop","height","scrollIntoView","block","setTimeout","scrollBehavior","borderTop","borderBottom","transition","setProperty","addEventListener","exitFullscreenSection","once","htmlFontSize","getComputedStyle","fontSize","replace","concat","removeProperty"],"mappings":";AACA,IAMIA,EANEC,EAAkBC,SAASC,cAAc,uBACzCC,EAAuBF,SAASC,cAAc,6BAC9CE,EAAWH,SAASC,cAAc,aAClCG,EAAgBJ,SAASC,cAAc,mBACvCI,EAASL,SAASC,cAAc,WAUhCK,EAAON,SAASC,cAAc,SAEpC,SAASM,IAEDC,OAAOC,YAAcN,EAASO,cAG9BJ,EAAKK,MAAMC,iBAAmB,EAO9BP,EAAOM,MAAME,OAAS,OAGtBV,EAASW,eAAe,CAAEC,MAAO,WAGjCC,WAAW,WAEPV,EAAKK,MAAMM,eAAiB,OAC5Bb,EAAcO,MAAME,OAAS,QAG7Bf,EAAqBK,EAASO,aAE9BN,EAAcO,MAAMO,WAAcV,OAAOC,YAAcN,EAASO,cAAgB,EAAK,mBACrFN,EAAcO,MAAMQ,cAAiBX,OAAOC,YAAcN,EAASO,cAAgB,EAAK,mBAMxFN,EAAcU,eAAe,CAAEC,MAAO,WAItCZ,EAASQ,MAAME,OAAS,QAIxBG,WAAW,WACPZ,EAAcO,MAAMS,WAAa,OACjCJ,WAAW,WACPZ,EAAcO,MAAMS,WAAa,QAClC,KAEHhB,EAAcO,MAAMO,UAAY,oBAChCd,EAAcO,MAAMQ,aAAe,qBACpC,GAKHhB,EAASQ,MAAMU,YAAY,oBAAqB,6BAOhDnB,EAAqBoB,iBAAiB,aAAcC,EAAuB,CAAEC,MAAM,IAKnFlB,EAAKK,MAAMM,eAAiB,SAK5BQ,aAAeC,iBAAiBpB,GAAMqB,SAASC,QAAQ,MAAO,IAE9DvB,EAAOM,MAAME,OAAMgB,GAAAA,OAAa,KAAOJ,aAAd,IAA8BjB,OAAOC,YAAe,OAS9E,OAGHN,EAASW,eAAe,CAAEC,MAAO,WACjChB,EAAgBuB,iBAAiB,aAAcf,EAAwB,CAAEiB,MAAM,KAOvF,SAASD,IAELlB,EAAOM,MAAMS,WAAa,OAE1Bf,EAAOM,MAAME,OAAS,OAGtBP,EAAKK,MAAMM,eAAiB,SAK5Bb,EAAcU,eAAe,CAAEC,MAAO,WAGtCC,WAAW,WAEPb,EAASQ,MAAMmB,eAAe,UAK9B3B,EAASQ,MAAMU,YAAY,oBAAqB,6BAMhDL,WAAW,WACPZ,EAAcO,MAAMS,WAAa,OACjCJ,WAAW,WACPZ,EAAcO,MAAMS,WAAa,QAClC,KACHhB,EAAcO,MAAMO,WAAcV,OAAOC,YAAcX,GAAsB,EAAK,mBAClFM,EAAcO,MAAMQ,cAAiBX,OAAOC,YAAcX,GAAsB,EAAK,oBACtF,GAGHC,EAAgBuB,iBAAiB,YAAaf,EAAwB,CAAEiB,MAAM,IAM9ER,WAAW,WAEPV,EAAKK,MAAMM,eAAiB,OAC5Bb,EAAcO,MAAMmB,eAAe,UAEnC1B,EAAcO,MAAMO,UAAY,oBAChCd,EAAcO,MAAMQ,aAAe,oBAEnChB,EAASW,eAAe,CAAEC,MAAO,WAIjCV,EAAOM,MAAME,OAAMgB,GAAAA,OAAa,KAAOJ,aAAd,IAA8BjB,OAAOC,YAAe,MAG7EH,EAAKK,MAAMM,eAAiB,UAC7B,MACJ,KA/DPlB,EAAgBuB,iBAAiB,aAAcf,EAAwB,CAAEiB,MAAM","file":"fullscreen-ordering.25126405.js","sourceRoot":"../../assets/src","sourcesContent":["\nconst orderingImgCont = document.querySelector('.ordering__img-cont');\nconst orderingImgContOuter = document.querySelector('.ordering__img-cont-outer');\nconst ordering = document.querySelector('.ordering');\nconst orderingOuter = document.querySelector('.ordering-outer');\nconst footer = document.querySelector('.footer');\n\nlet orderingInitHeight;\n\n// создаём тег style в HEAD - вутри него можно применять и изменять сойства для псевдоэлементов\n// let styleElem = document.head.appendChild(document.createElement(\"style\"));\n\n// ! selecting an <html> tag element - 3 ways:\n// const html = document.getElementsByTagName('html')[0];\n// const html = document.body.parentNode;\nconst html = document.querySelector(':root');\n\nfunction enterFullscreenSection() {\n    // применяем разворачивание секции ordering на весь экран только если высота экрана больше высоты секции ordering\n    if (window.innerHeight > ordering.offsetHeight) {\n\n        // убираем паддинг прокрутки до элемента\n        html.style.scrollPaddingTop = 0;\n\n        // // задаем плавность перехода блока с фоном (ordering)\n        // убрал transition для блока с фоном - т.к. анимированое разворачивание происходит за счёт бордеров внешнего блока-обёртки\n        // ordering.style.transition = '0.5s';\n\n        // из CSS ((100vh - 50vh) / 2) = 25vh . 50vh - это высота ordering (и orderingOuter)\n        footer.style.height = '25vh';\n\n        // скроллим блок с фоном (ordering) в центр экрана\n        ordering.scrollIntoView({ block: \"center\" });\n\n        //задаём отсрочку в 0.5 секунды чтобы страница успела проскроллиться до блока с фоном (ordering) и/или отыгралась анимация увеличения картинки, после этого делаем анимацию разворачивания\n        setTimeout(() => {\n            // убираем плавность прокрутки (скроллинга) страницы, разворачиваем блок-обёртку на всю высоту экрана и cкроллим блок обертку в центр экрана (т.е. он займёт весь экран) - все эти (три) действия происходят мгновенно - пользователь видит на экране только появление контента соседних блоков\n            html.style.scrollBehavior = 'auto';\n            orderingOuter.style.height = '100vh';\n\n            // Записываем в переменную orderingInitHeight текущую высоту блока с фоном (ordering)\n            orderingInitHeight = ordering.offsetHeight;\n            // задаём блоку-обёртке orderingOuter верхний и нижний бордеры (с цветом в цвет соседей) такой высоты, чтобы блок с фоном (ordering) оказался точно в центре блоку обёртки - (т.е. ка бы закрываем створки ограничивающие внутренний блок)\n            orderingOuter.style.borderTop = ((window.innerHeight - ordering.offsetHeight) / 2) + 'px solid #FFEEEF';\n            orderingOuter.style.borderBottom = ((window.innerHeight - ordering.offsetHeight) / 2) + 'px solid #FFEEEF';\n\n\n            //  убрал - т.к. это работало без глюка только до 1440х900\n            // window.scrollBy(0, ((window.innerHeight - ordering.offsetHeight) / 2));\n            // !!! нужно временно добавить высоты футеру ( и с задержкой убрать в этой же функции) чтобы не было \"скачка\" на больших разрешениях, где нельзя промотать ordering.scrollIntoView({ block: \"center\" }); ( добавлять до line 22) в центр экрана !!!\n            orderingOuter.scrollIntoView({ block: \"center\" });\n\n\n            // разворачиваем блок с фоном (ordering) на всю высоту экрана (происходит с анимацией благодаря раннее присвоенному transition  - убрал transition  чтобы было меньше исполняемых анимация т.к. уже используем бордеры с transition)\n            ordering.style.height = '100vh';\n\n\n            // Добавляем плавность (transition  = '0.5s') orderingOuter - и убираем бордеры. после завершения transition (т.е. через 0.5сек) - убираем\n            setTimeout(() => {\n                orderingOuter.style.transition = '0.5s';\n                setTimeout(() => {\n                    orderingOuter.style.transition = '0.0s';\n                }, 500);\n                // Убираем  в ноль бордеры, закрывающие блок с фоном (происходит с анимацией благодаря раннее присвоенному (на 0.5сек) transition)\n                orderingOuter.style.borderTop = '0px solid #FFEEEF';\n                orderingOuter.style.borderBottom = '0px solid #FFEEEF';\n            }, 0);\n\n            // делаем фоновую картинку более ясно видимой\n            // ordering.style.backgroundColor = 'rgba(240, 237, 243, 0.75)';\n            // меняем значение переменной CSS - изменится значение свойства у псевдоэлемента (оно задано переменной CSS)\n            ordering.style.setProperty('--orderingBGColor', 'rgba(240, 237, 243, 0.75)');\n            //  изменяем стиль псевдоэлемента меняя содержимое тега style в head-е\n            // styleElem.innerHTML = '.ordering::before {transition: 0.5s; background-color: rgba(240, 237, 243, 0.75)}'\n\n\n            // orderingImgCont.addEventListener('mouseleave', exitFullscreenSection, { once: true });\n            // вешаем слушатель события на блок-обёртку контейнера картинки (у него высота 100% родителя) - чтоб не было зацикленного разворачивания сворачивания при определённном положении курсора мыши и скролла страницы\n            orderingImgContOuter.addEventListener('mouseleave', exitFullscreenSection, { once: true });\n\n            // не БАГ а ФИЧА - если быстро (быстрее 0.5сек) убрать курсор с картинки - блок с фоном (ordering) останется развёрнутым на весь экран, при повторном наведении и убирании блок с фоном сворачивается - это не ломает сайт - оставил такую возможность пользователю обнаружить и совершать такое \"переключение\") \n\n            // возвращаем плавность скролла - на случай если пользователь будет пользоваться сайтом после использования \"переключения\" багофичей)\n            html.style.scrollBehavior = 'smooth';\n\n            // возвращаем футер к нормальному размеру, пересчитывая высоту по макету  133px (или 13.5rem) в vh. 10 - это размер шрифта в HTML (переделать в переменную и брать из CSS!!!)\n            // htmlFontSize = getComputedStyle(html).getPropertyValue('font-size');\n            // htmlFontSize = getComputedStyle(html).fontSize.replace(/[^0-9]/g, \"\"); // - OK! Lasts only digits and replace all else non-digits with nothing\n            htmlFontSize = getComputedStyle(html).fontSize.replace(/\\D/g, \"\"); // - OK! Replace all leading non-digits with nothing - more common way\n            // console.log(htmlFontSize);\n            footer.style.height = `${100 * (13.3 * htmlFontSize) / window.innerHeight}vh`;\n\n            // // масштабирование псевдоэлемента с фоном тормозит на MacBook Pro 2015 - не применяем\n            // document.onmousemove = function (event) {\n            //     // styleElem.innerHTML = '.ordering::before {transform: scale(' + ((1.2 + (1.0 * event.clientX / 10000)) - (event.clientY / 8000)) + ')}'\n            //     let transformBgBefore = 'scale(' + ((1.1 + (1.0 * event.clientX / 15000)) - (event.clientY / 10000)) + ')'\n\n            //     ordering.style.setProperty('--transformBgBefore', transformBgBefore);\n            // }\n        }, 500);\n    } else {\n        // если высота экрана больше высоты блока с фоном (ordering) - только центрируем и вешаем однократный листнер - на случай увеличения высоты экрана (окна браузера) или повторного наведени после скролла\n        ordering.scrollIntoView({ block: \"center\" });\n        orderingImgCont.addEventListener('mouseenter', enterFullscreenSection, { once: true });\n    }\n}\n\n// вешаем первоначальный однократный листнер для разворачивания блока с фоном (ordering)\norderingImgCont.addEventListener('mouseenter', enterFullscreenSection, { once: true });\n\nfunction exitFullscreenSection() {\n    //  для возможности прокрутки блока с фоном в центр экрана (на больших экранах) - после мгновенного сворачивания блока-обёртки блока с фоном - \n    footer.style.transition = '0.5s';\n    // из CSS ((100vh - 50vh) / 2) = 25vh . 50vh - это высота ordering (и orderingOuter)\n    footer.style.height = '25vh';\n\n    // возвращаем плавность скролла (на случай, если пользователь скроллил страницу с развернуым блоком с фоном)\n    html.style.scrollBehavior = 'smooth';\n\n    // задаём \"нулевую\" (16 мс = 1fps 60Hz) задержку чтобы сработало html.style.scrollBehavior = 'smooth'; - плавность скролла  - нужно было при разработке - сейчас - не требуется\n    // setTimeout(() => {\n    //прокручиваем блоком с фоном в центр экрана\n    orderingOuter.scrollIntoView({ block: \"center\" });\n\n    //задаём отсрочку в 0.5 секунды чтобы страница успела проскроллиться до блока с фоном (ordering) и/или отыгралась анимация увеличения картинки, после этого делаем анимацию разворачивания\n    setTimeout(() => {\n        // убираем высоту на весь экран у блока с фоном - происходит с анимацией за счёт transition  - убрал transition чтобы было меньше исполняемых анимация т.к. уже используем бордеры с transition\n        ordering.style.removeProperty('height');\n\n        // делаём фоновую картинку обратно более блёклой\n        // ordering.style.backgroundColor = 'rgba(240, 237, 243, 0.99)';\n        // меняем значение переменной CSS - изменится значение свойства у псевдоэлемента (оно задано переменной CSS)\n        ordering.style.setProperty('--orderingBGColor', 'rgba(240, 237, 243, 0.99)');\n        // изменяем стиль псевдоэлемента меняя содержимое тега style в head-е\n        // styleElem.innerHTML = '.ordering::before {transition: 0.5s; background-color: rgba(240, 237, 243, 0.99)}'\n\n\n        // плавно возвращаем размер ограничивающих фон бордеров до первоначального состояния (используя сохранённое в переменную orderingInitHeight значение высоты блока с фоном (ordering) в момент старта разворачивания)\n        setTimeout(() => {\n            orderingOuter.style.transition = '0.5s';\n            setTimeout(() => {\n                orderingOuter.style.transition = '0.0s';\n            }, 490);\n            orderingOuter.style.borderTop = ((window.innerHeight - orderingInitHeight) / 2) + 'px solid #FFEEEF';\n            orderingOuter.style.borderBottom = ((window.innerHeight - orderingInitHeight) / 2) + 'px solid #FFEEEF';\n        }, 0);\n\n        // вешаем  однократный листнер для разворачивания блока с фоном (ordering) - теперь на событие 'mousemove' - чтобы не было глюка с повторным проигрыванием анимации после скрола из-за попадания неподвижного указателя мыши на картинку\n        orderingImgCont.addEventListener('mousemove', enterFullscreenSection, { once: true });\n\n        // не требуется запрещать полдьзователю скролл страницы - глюков нет\n        // document.body.style.overflow = 'hidden';\n\n        // делаем задержку на время анимации сворачивания блока с фоном\n        setTimeout(() => {\n            // убираем плавность прокрутки (скроллинга) страницы, сворачиваем блок-обёртку (убирая бордеры) и скроллим блок с фоном (ordering) в центр - все эти действия происходят мгновенно - пользователь видит на экране только появление контента соседних блоков (в том числе за счёт одинакового цвета фона блока-обёртки и соседних блоков) \n            html.style.scrollBehavior = 'auto';\n            orderingOuter.style.removeProperty('height');\n\n            orderingOuter.style.borderTop = '0px solid #FFEEEF';\n            orderingOuter.style.borderBottom = '0px solid #FFEEEF';\n\n            ordering.scrollIntoView({ block: \"center\" });\n\n            // footer.style.height = '13.5rem';\n            // возвращаем футер к нормальному размеру, пересчитывая высоту по макету  133px в vh. 10 - это размер шрифта в HTML (переделать в переменную и брать из CSS!!!)\n            footer.style.height = `${100 * (13.3 * htmlFontSize) / window.innerHeight}vh`;\n\n            // возвращаем плавность скролла - для дальнейшего просмотра сайта\n            html.style.scrollBehavior = 'smooth';\n        }, 500);\n    }, 500);\n    // }, 16);\n}\n\n// orderingImgCont.addEventListener('mouseleave', exitFullscreenSection);\n\n"]}